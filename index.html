<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Glowing Sphere with Particle Rings</title>
  <link rel="stylesheet" href="style.css" />
  <style>
    body, html {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background-color: #000;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script>
    const canvas = document.getElementById('canvas');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setClearColor(0x000000, 0); // transparent background

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 5;

    // Create glowing sphere as particles
    const sphereParticleCount = 1000;
    const spherePositions = [];
    const sphereColors = [];
    const color = new THREE.Color();

    for (let i = 0; i < sphereParticleCount; i++) {
      // Random point on sphere surface
      const theta = Math.random() * 2 * Math.PI;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 1.0; // radius of sphere

      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);

      spherePositions.push(x, y, z);

      // Color gradient from pink to blue based on y position
      color.setHSL((y + 1) / 2 * 0.7 + 0.6, 1.0, 0.6);
      sphereColors.push(color.r, color.g, color.b);
    }

    const sphereGeometry = new THREE.BufferGeometry();
    sphereGeometry.setAttribute('position', new THREE.Float32BufferAttribute(spherePositions, 3));
    sphereGeometry.setAttribute('color', new THREE.Float32BufferAttribute(sphereColors, 3));

    const sphereMaterial = new THREE.PointsMaterial({
      size: 0.05,
      vertexColors: true,
      blending: THREE.AdditiveBlending,
      transparent: true,
      depthWrite: false,
    });

    const sphereMesh = new THREE.Points(sphereGeometry, sphereMaterial);
    scene.add(sphereMesh);

    // Create particle rings
    const ringCount = 3;
    const rings = [];
    const ringRadius = 1.7; // same radius for all rings

    for (let i = 0; i < ringCount; i++) {
      const particleCount = 300;
      const positions = [];
      const colors = [];
      const radius = ringRadius;
      const color = new THREE.Color();

      for (let j = 0; j < particleCount; j++) {
        const angle = (j / particleCount) * Math.PI * 2;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        const z = 0;

        positions.push(x, y, z);

        // Color gradient for particles in ring
        color.setHSL((j / particleCount + i * 0.3) % 1, 1.0, 0.6);
        colors.push(color.r, color.g, color.b);
      }

      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));

      const material = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        transparent: true,
        depthWrite: false,
      });

      const points = new THREE.Points(geometry, material);

      // Rotate each ring differently in 3D space
      points.rotation.x = i * 0.7;
      points.rotation.y = i * 0.5;

      scene.add(points);
      rings.push(points);
    }
    // Create shiny particles on sphere surface
    const shinyParticleCount = 200;
    const shinyPositions = [];
    const shinyColors = [];
    const shinyColor = new THREE.Color(1, 1, 1); // white shiny particles

    for (let i = 0; i < shinyParticleCount; i++) {
      // Random point on sphere surface
      const theta = Math.random() * 2 * Math.PI;
      const phi = Math.acos(2 * Math.random() - 1);
      const r = 1.0; // radius of sphere

      const x = r * Math.sin(phi) * Math.cos(theta);
      const y = r * Math.sin(phi) * Math.sin(theta);
      const z = r * Math.cos(phi);

      shinyPositions.push(x, y, z);

      // White color for shiny particles
      shinyColors.push(shinyColor.r, shinyColor.g, shinyColor.b);
    }

    const shinyGeometry = new THREE.BufferGeometry();
    shinyGeometry.setAttribute('position', new THREE.Float32BufferAttribute(shinyPositions, 3));
    shinyGeometry.setAttribute('color', new THREE.Float32BufferAttribute(shinyColors, 3));

    const shinyMaterial = new THREE.PointsMaterial({
      size: 0.07,
      vertexColors: true,
      blending: THREE.AdditiveBlending,
      transparent: true,
      depthWrite: false,
    });

    const shinyParticles = new THREE.Points(shinyGeometry, shinyMaterial);
    scene.add(shinyParticles);

    // Animation loop
    function animate(time) {
      time *= 0.001; // convert to seconds

      // 3D movement of sphere
      sphereMesh.position.x = Math.sin(time * 0.7) * 0.5;
      sphereMesh.position.y = Math.cos(time * 0.5) * 0.3;
      sphereMesh.position.z = Math.sin(time * 0.3) * 0.4;

      sphereMesh.rotation.y = time * 0.3;

      rings.forEach((ring, i) => {
        ring.rotation.x += 0.01 + i * 0.005;
        ring.rotation.y += 0.02 + i * 0.01;
      });

      shinyParticles.rotation.y = time * 0.5;

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    // Handle window resize
    window.addEventListener('resize', () => {
      const width = window.innerWidth;
      const height = window.innerHeight;
      renderer.setSize(width, height);
      camera.aspect = width / height;
      camera.updateProjectionMatrix();
    });
  </script>
</body>
</html>
